import { Maybe } from "./Maybe";
type MaybeOf<M> = M extends Maybe<infer A> ? A : never;
export declare class Lens<A, B> {
    readonly get: (a: A) => B;
    readonly set: (a: A, b: B) => A;
    constructor(get: (a: A) => B, set: (a: A, b: B) => A);
    update(a: A, f: (b: B) => B): A;
    updateWithResult<R>(a: A, f: (b: B) => [B, R]): [A, R];
    field<K extends keyof B>(field: K): Lens<A, B[K]>;
    sub<C extends B>(f: (b: B) => Maybe<C>): Prism<A, C>;
    flatten(): Prism<A, MaybeOf<B>>;
    andThenLens<C>(lens: Lens<B, C>): Lens<A, C>;
    andThenPrism<C>(prism: Prism<B, C>): Prism<A, C>;
}
export declare class Prism<A, B> {
    readonly get: (a: A) => Maybe<B>;
    readonly set: (a: A, b: B) => A;
    constructor(get: (a: A) => Maybe<B>, set: (a: A, b: B) => A);
    update(a: A, f: (b: B) => B): Maybe<A>;
    updateWithResult<R>(a: A, f: (b: B) => [B, R]): Maybe<[A, R]>;
    field<K extends keyof B>(field: K): Prism<A, B[K]>;
    sub<C extends B>(f: (b: B) => Maybe<C>): Prism<A, C>;
    andThen<C>(lens: Lens<B, C> | Prism<B, C>): Prism<A, C>;
    flatten(): Prism<A, MaybeOf<B>>;
}
export type SubTypeGuard<A, B extends A> = (a: A) => Maybe<B>;
export declare function idLens<A>(): Lens<A, A>;
export declare function composeLenses<A, B, C>(l1: Lens<A, B>, l2: Lens<B, C>): Lens<A, C>;
export declare function composeLensPrism<A, B, C>(l: Lens<A, B>, p: Prism<B, C>): Prism<A, C>;
export declare function composePrismLens<A, B, C>(p: Prism<A, B>, l: Lens<B, C>): Prism<A, C>;
export declare function composePrisms<A, B, C>(p: Prism<A, B>, p2: Prism<B, C>): Prism<A, C>;
export declare function fieldLens<A, K extends keyof A>(field: K): Lens<A, A[K]>;
export declare function flattenPrism<A>(): Prism<Maybe<MaybeOf<A>>, MaybeOf<A>>;
export declare function discriminate<B, C extends B, K extends keyof B>(tag: K, v: C[K]): SubTypeGuard<B, C>;
export declare function subPrism<A, B extends A>(f: (a: A) => Maybe<B>): Prism<A, B>;
export {};
