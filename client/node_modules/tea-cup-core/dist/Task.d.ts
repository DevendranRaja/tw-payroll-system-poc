import { Cmd } from './Cmd';
import { Result } from './Result';
/**
 * Base class for Tasks.
 */
export declare abstract class Task<E, R> {
    /**
     * To be implemented by concrete Tasks.
     * @param callback the callback to call when the task is ran
     */
    abstract execute(callback: (r: Result<E, R>) => void): void;
    /**
     * Send a Task to the runtime for execution
     * @param t the task
     * @param toMsg a function that turns the result of the task into a Msg
     */
    static attempt<E, R, M>(t: Task<E, R>, toMsg: (r: Result<E, R>) => M): Cmd<M>;
    /**
     * Send a Task that never fails to the runtime for execution
     * @param t the task
     * @param toMsg a function that turns the result of the task into a Msg
     */
    static perform<R, M>(t: Task<never, R>, toMsg: (r: R) => M): Cmd<M>;
    /**
     * Create a task that succeeds with a value
     * @param r the value
     */
    static succeed<R>(r: R): Task<never, R>;
    /**
     * Create a task that succeeds with a lazily-supplied value
     * @param r the value supplier
     */
    static succeedLazy<R>(r: () => R): Task<never, R>;
    /**
     * Create a task that fails with an error
     * @param e the error
     */
    static fail<E>(e: E): Task<E, never>;
    /**
     * Create a task that fails with a lazily-supplied error
     * @param e the error supplier
     */
    static failLazy<E>(e: () => E): Task<E, never>;
    /**
     * Create a task from a Promise
     * @param promiseSupplier a function that returns the promise (will be called on Task execution)
     */
    static fromPromise<R>(promiseSupplier: PromiseSupplier<R>): Task<any, R>;
    /**
     * Create a task from a supplier (lazy). Will return an error if the lambda throws an error.
     */
    static fromLambda<R>(lambda: () => R): Task<Error, R>;
    /**
     * Map the ok result of this task
     * @param f the mapping function
     */
    map<R2>(f: (r: R) => R2): Task<E, R2>;
    /**
     * Map the error result of this task
     * @param f the mapping function
     */
    mapError<E2>(f: (e: E) => E2): Task<E2, R>;
    /**
     * Recover from error (turns error into a success !)
     * @param f the error-to-success converter
     */
    recover(f: (e: E) => R): Task<never, R>;
    /**
     * Chain this task with another task
     * @param f a function that accepts the result of this task, and yields a new task
     */
    andThen<R2>(f: (r: R) => Task<E, R2>): Task<E, R2>;
    /**
     * Runs tasks in parallel
     * @param t the task to be run in parallel with this task
     * @param f a function that maps the results of the 2 parallel tasks
     */
    parallel<T2, R2>(t: Task<E, T2>, f: (a: R, b: T2) => R2): Task<E, R2>;
}
export type PromiseSupplier<T> = () => Promise<T>;
